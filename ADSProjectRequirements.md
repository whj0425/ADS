
**Project Assignment: Building Focused Distributed Systems**

**Project Goals:** This project reinforces core distributed systems concepts through the design and

implementation of a targeted distributed application.

**Team Size:** Teams of two students.

**Project Timeline (Approximately):**

· **Week 5: Project Proposal:** A concise plan outlining your application, design, and initial

implementation strategy.

· **Week 8: Final Project Presentation & Code Review (During Final Class):** Comprehensive

demonstration, key code walkthrough, and system evaluation.

**Project Requirements:**

1\. **Focused Distributed Architecture:**

· Design a system with at least three interacting nodes.

· Demonstrate a clear understanding of distributed communication.

· A simple centralized node for initial connection is allowed.

2\. **Core Shared State Management:**

· Implement a system that manages a small, shared dataset.

· Focus on demonstrating basic concurrency control and consistency.

· Real time updates are desired, but not required if too complex.

3\. **Basic Fault Tolerance:**

· Implement a simple fault-tolerance mechanism (e.g., basic replication or failure

detection).

· Demonstrate how your system handles a single node failure.

4\. **Scalability Considerations (Conceptual):**

· Describe (in your proposal and presentation) how your design could be extended to

handle more nodes.

· Actual implementation of large-scale scalability is not required.

5\. **Implementation:**

· Choose a suitable programming language (Go, Python, Java).

· Prioritize clarity and functionality over complex features.

· Avoid external distributed system frameworks for core logic.

6\. **Tiered Implementation (Simplified):**

· Focus on achieving a functional base system first.

· Add one or two key enhancements if time permits.

7\. **Testing and Evaluation (Focused):**

· Demonstrate basic unit or integration tests.

· Show how you tested for node failures.



<a name="br2"></a> 

**Project Proposal (3-4 Pages):**

· **Application Overview:**

· Clearly define the application's purpose and scope.

· **System Design:**

· Provide a simple diagram of the system architecture.

· Describe the data being shared and how nodes communicate.

· **Distributed System Mechanisms:**

· Specify the concurrency control and fault-tolerance techniques used.

· **Testing Plan:**

· Outline your basic testing approach.

· **Implementation Plan:**

· Outline the base functionality that will be completed, and any stretch goals.

**Evaluation Criteria (Prioritized):**

· **Distributed System Understanding:** Demonstrated understanding of core concepts.

· **Implementation Functionality:** Functionality of the core system.

· **Fault Tolerance:** Basic ability to handle node failures.

· **Code Clarity:** Readability and organization of the code.

· **Presentation:** Clarity and conciseness of the presentation.

**Project Ideas (Simplified Examples):**

Choose your own project idea, something that is of interest to you, the projects ideas defined

below are just for reference and is not mandatory to choose them

· **Simple Distributed Chat:** A basic chat application with a shared chat room.

· **Distributed Key-Value Store (Simplified):** A basic key-value store with replication.

· **Distributed sensor network:** A system that collects sensor data from multiple nodes and

displays it.

**Key Considerations:**

· **Emphasis on Core Concepts:** Focus on demonstrating fundamental distributed systems

principles.

· **Simplified Scope:** Choose projects that are achievable within the limited timeframe.

· **Clear Communication:** Encourage regular communication between team members and the

instructor.

· **Prioritize Functionality:** Focus on getting a working system rather than implementing

complex features.

· **Concise Documentation:** Emphasize clear and concise documentation.

· **Use of simple tools:** Make sure that the tools used are easy to use, and that the students are

already familiar with them, or can learn them quickly.


